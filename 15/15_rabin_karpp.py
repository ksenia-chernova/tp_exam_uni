"""
АЛГОРИТМ РАБИНА-КАРПА
Поиск подстроки с использованием хеширования

Хеширование — это процесс преобразования данных (например, текста, файла или транзакции) 
в строку фиксированной длины, которая называется хешем или хеш-кодом. 
Это преобразование выполняется с помощью специальной математической функции — хеш-функции



ПОДРОБНОЕ ПОШАГОВОЕ ОБЪЯСНЕНИЕ РАБОТЫ АЛГОРИТМА:
1. ИНИЦИАЛИЗАЦИЯ ПАРАМЕТРОВ:
python
B = 13      # Основание (base). Для текста обычно 31, 37, 256
Q = 256     # Простое число для модуля. Чем больше, тем меньше коллизий
2. КАК РАБОТАЕТ ХЕШ-ФУНКЦИЯ:
Для строки "mem":

text
Шаг 1: 'm' (код 109) → hash = (13*0 + 109) % 256 = 109
Шаг 2: 'e' (код 101) → hash = (13*109 + 101) % 256 = 174
Шаг 3: 'm' (код 109) → hash = (13*174 + 109) % 256 = 67
Итог: hash("mem") = 67
3. ВЫЧИСЛЕНИЕ MULTIPLIER:
multiplier = B^(pattern_len-1) % Q

Для pattern_len=3:

text
multiplier = 13^(3-1) % 256 = 169
4. СКОЛЬЗЯЩЕЕ ХЕШИРОВАНИЕ - САМАЯ ВАЖНАЯ ЧАСТЬ:
Допустим, у нас окно "abc" и мы сдвигаем его на "bcd":

text
Текущий хеш для "abc": hash_abc = (a*B² + b*B + c) % Q

Нужно вычислить хеш для "bcd":
1. Удаляем 'a': hash_abc - a*B²
2. Сдвигаем: (hash_abc - a*B²) * B
3. Добавляем 'd': (hash_abc - a*B²) * B + d
4. Берём по модулю: ((hash_abc - a*B²) * B + d) % Q

Где B² = multiplier
5. ПРИМЕР РАБОТЫ АЛГОРИТМА:
Дано:

Текст: "abcmemdefmem"

Подстрока: "mem" (хеш = 67)

Шаг 0:

text
Окно: "abc" (первые 3 символа)
Хеш окна: get_hash("abc") = X1
Сравниваем: 67 != X1 → нет совпадения
Шаг 1: Сдвигаем окно на "bcd"

text
Вычисляем новый хеш по формуле скользящего хеша
Хеш окна: X2
67 != X2 → нет совпадения
Шаг 2: Окно "cme"

text
Хеш окна: X3
67 != X3 → нет совпадения
Шаг 3: Окно "mem"

text
Хеш окна: вычисляем = 67
Хеши совпали! Проверяем посимвольно:
"mem" == "mem" ✓ → count = 1
6. ПОЧЕМУ НУЖНА ПРОВЕРКА ПОСИМВОЛЬНО:
Из-за коллизий хешей разные строки могут иметь одинаковый хеш:

text
Пример коллизии:
hash("ab") = hash("ba") при неудачных B и Q
Поэтому при совпадении хешей проверяем строки посимвольно
7. ПРЕИМУЩЕСТВА ЭТОЙ РЕАЛИЗАЦИИ:
Эффективность: Пересчет хеша за O(1) вместо O(m)

Универсальность: Работает с любыми текстами

Производительность: В среднем O(n + m) операций

Память: Требует O(1) дополнительной памяти

8. ВОЗМОЖНЫЕ ПРОБЛЕМЫ И ИХ РЕШЕНИЕ:
Проблема 1: Отрицательный хеш

python
if main_text_hash < 0:
    main_text_hash += Q
Решение: добавляем Q, чтобы получить положительное значение

Проблема 2: Коллизии
Решение: использование большого простого Q и проверка посимвольно

Проблема 3: Переполнение
Решение: операция модуля % Q предотвращает переполнение

9. СОВЕТЫ ПО ВЫБОРУ ПАРАМЕТРОВ:
B (base):

Для ASCII: 128 или 256

Для текста на английском: 31, 37

Чем больше, тем меньше коллизий

Q (prime):

Должно быть большим простым числом

Часто используют: 2³¹-1, 2⁶¹-1

В данном примере 256 маловато (много коллизий)

10. ПРОИЗВОДИТЕЛЬНОСТЬ НА БОЛЬШИХ ТЕКСТАХ:
Для текста из 1 миллиона символов и подстроки из 3 символов:

Наивный алгоритм: ~1 млн × 3 сравнений = 3 млн операций

Рабин-Карп: ~1 млн + 3 операций + проверки при коллизиях

Ускорение в 2-3 раза на практике

Эта реализация оптимальна для поиска в больших текстах и часто 
используется в реальных приложениях (текстовые редакторы, поисковые системы, антивирусы).
"""

import time

# Глобальные константы:
# B - основание системы счисления (обычно размер алфавита)
# Q - простое число для операции модуля (уменьшает коллизии)
B = 13
Q = 256


def get_hash(pattern: str) -> int:
    """
    Вычисляет полиномиальный хеш для строки
    
    Формула: hash = (c1 * B^(m-1) + c2 * B^(m-2) + ... + cm) % Q
    где c1, c2, ... cm - коды символов, m - длина строки
    
    Args:
        pattern: строка, для которой вычисляется хеш
        
    Returns:
        целочисленный хеш-значение
    """
    global B, Q
    m = len(pattern)  # Длина строки
    result = 0  # Начальное значение хеша
    
    # Последовательно вычисляем хеш для каждого символа
    for i in range(m):
        # Формула: новый_хеш = (B * старый_хеш + код_символа) % Q
        result = (B * result + ord(pattern[i])) % Q
    
    return result


def search_patterns_in_text(main_text: str, pattern: str) -> None:
    """
    Основная функция поиска подстроки в тексте с использованием алгоритма Рабина-Карпа
    
    Args:
        main_text: текст, в котором производится поиск
        pattern: подстрока, которую нужно найти
        
    Returns:
        None (результаты выводятся на экран)
    """
    global B, Q
    
    # Длины текста и подстроки
    pattern_len = len(pattern)
    main_text_len = len(main_text)
    
    # 1. Вычисляем multiplier = B^(pattern_len-1) % Q
    #    Нужен для скользящего хеширования
    multiplier = 1
    for i in range(1, pattern_len):
        multiplier = (multiplier * B) % Q
    
    # 2. Вычисляем хеши:
    #    - pattern_hash: хеш искомой подстроки
    #    - main_text_hash: хеш первого окна текста (той же длины, что и подстрока)
    pattern_hash = get_hash(pattern)
    main_text_hash = get_hash(main_text[:pattern_len])
    
    # 3. Список для хранения индексов найденных вхождений
    indices = []  # ИЗМЕНИЛИ: было count = 0, теперь indices = []
    
    # 5. Основной цикл поиска
    #    Проходим по всем возможным позициям окна в тексте
    for index_symbol in range(main_text_len - pattern_len + 1):
        # 5.1. Сравниваем хеши
        if pattern_hash == main_text_hash:
            # Хеши совпали, проверяем строки посимвольно (избегаем коллизий)
            if main_text[index_symbol: index_symbol + pattern_len] == pattern:
                indices.append(index_symbol)  # ИЗМЕНИЛИ: было count += 1, теперь добавляем индекс
    
        # 5.2. Пересчитываем хеш для следующего окна (скользящее хеширование)
        #      Делаем это только если не достигли конца текста
        if index_symbol < main_text_len - pattern_len:
            # Формула скользящего хеша:
            # новый_хеш = ((старый_хеш - код_удаляемого_символа * multiplier) * B + код_добавляемого_символа) % Q
            
            # Удаляем вклад символа, который выходит из окна
            remove_component = ord(main_text[index_symbol]) * multiplier
            
            # Вычисляем новый хеш
            main_text_hash = ((main_text_hash - remove_component) * B + 
                             ord(main_text[index_symbol + pattern_len])) % Q
            
            # Обрабатываем случай отрицательного хеша
            if main_text_hash < 0:
                main_text_hash += Q
    
    # 7. Выводим результаты
    print(indices)  # ИЗМЕНИЛИ: было print(f"Result: {count}"), теперь просто выводим список

string = input()
substring = input()
search_patterns_in_text(string, substring)